"""Detectors for patterns for unitary transformations."""

from abstract_detector import PatternDetector

from qiskit import QuantumCircuit
from qiskit.circuit.quantumcircuit import BitLocations, Qubit
from qiskit.converters import circuit_to_dag, dag_to_circuit
from qiskit.dagcircuit import DAGCircuit, DAGOpNode
from qiskit.circuit.library import HGate, CXGate, SwapGate, Measure
from io import TextIOWrapper


class PhaseEstimationDetector(PatternDetector):
    """Detector for the pattern Quantum Phase Estimation."""

    def __init__(self, program: TextIOWrapper) -> None:
        """Create a new detector for Quantum Phase Estimation.
        
        Args:
            program (TextIOWrapper): Wrapper that encodes the OPENQASM file in which patterns should be detected.
        """
        super().__init__(program)
        self.load_circuit(self.program)

    # Search for the special circuit used for PhaseEstimation.
    def detect_pattern(self) ->  bool:
        """Detect instances of Quantum Phase Estimation.
        
        Quantum Phase Estimation is used for approximating the eigenvalue of a unitary transformation. 
        The pattern is detected by searching the typcial circuit structure.

        Returns:
            bool: True if an instance of Quantum Phase Estimation was detected, False otherwise.
        """
        dag: DAGCircuit = circuit_to_dag(self.circuit)

        # Stores bits in unifrom superposition with the corresponding gates.
        # key: possible gate and the bits it operates on
        # value: list of hadamard transformed bits
        hadamards: dict[str, list[tuple[int, bool]]] = {}

        found_u: bool = False

        # Iterate through all layers of the circuit.
        for layer in dag.layers():

            # First iteration to fing U gates.
            for node in layer['graph'].front_layer():

                qubit: Qubit = node.qargs[0]
                location: BitLocations = self.circuit.find_bit(qubit)
                qubit_index: int = location.index

                # Look for U gates.
                if node.op.num_qubits > 1:
                    found_u = True
                    operating_bits: list[int] = []
                    for i in range(1, len(node.qargs)):
                        o_qubit: Qubit = node.qargs[i]
                        location: BitLocations = self.circuit.find_bit(o_qubit)
                        operating_bits.append(location.index)

                    for key, value in hadamards.copy().items():
                        if qubit_index not in value[0]:
                            del hadamards[key]
                            continue

                        # Remove name appendices generated by Qiskit.
                        name = ''.join([i for i in node.name if not i.isdigit()])

                        if not name[-1].isalpha():
                            name = name[:-1]
                        
                        # Save gate name and the operating qubits in key.
                        current_key: str = repr((name, operating_bits))
                        if key == "": 
                            hadamards[current_key] = hadamards.pop("")
                            if (qubit_index, False) in hadamards[current_key]:
                                hadamards[current_key].remove((qubit_index, False))
                                hadamards[current_key].append((qubit_index, True))
                            continue

                        if key != current_key:
                            del hadamards[key]
                            continue

                        if (qubit_index, False) in hadamards[current_key]:
                            hadamards[key].remove((qubit_index, False))
                            hadamards[key].append((qubit_index, True))

            if not found_u:
                hadamards.clear()

            found_u = False

            # Second iteration for adding Hadamard transformed qubits.
            for node in layer['graph'].front_layer():   
                if node.name == HGate().name:

                    qubit: Qubit = node.qargs[0]
                    location: BitLocations = self.circuit.find_bit(qubit)
                    qubit_index: int = location.index

                    if "" in hadamards.keys():
                        hadamards[""].append((qubit_index, False))
                        continue

                    hadamards[""] = [(qubit_index, False)]

            # If all ancillary bits are used, an instance of the pattern has been found.
            for value in hadamards.values():
                marks: set[bool] = {mark for _, mark in value}
                if len(marks) == 1 and marks.pop():
                    return True
                
        return False

    
    def build_message(self) -> str:
        """Construct a human-readable message about the detection result.
        
        Returns:
            str: Message with information whether an instance of Quantum Phase Estimation was detected.
        """
        if self.detect_pattern():
            return "Quantum Phase Estimation: Instance of Quantum Phase Estimation detected.\n"

        return "Quantum Phase Estimation: No instance detected.\n"


class UncomputeDetector(PatternDetector):
    """Detector for the pattern Uncompute."""
    
    def __init__(self, program: TextIOWrapper) -> None:
        """Create a new detector for Uncompute.
        
        Args:
            program (TextIOWrapper): Wrapper that encodes the OPENQASM file in which patterns should be detected.
        """
        super().__init__(program)
        self.load_circuit(self.program)

    def detect_pattern(self) -> bool:
        """Detect instances of Uncompute.
        
        Uncompute refers to the process of removing entanglement in the quantum state. The pattern is detected by
        searching for the typical circuit structure and subcircuits that are inverse to other subcircuits of the given
        quantum circuit.

        Returns:
            bool: True if an instance of Uncompute was detected, False otherwise. 
        """
        return self.detect_circuit_struc() or self.detect_inverse_subcircuit()

    def build_message(self) -> str:
        """Construct a human-readable message about the detection result.
        
        Returns:
            str: Message with information whether an instance of Uncompute was detected.
        """
        if self.detect_pattern():
            return "Uncompute: Instance of Uncompute detected.\n"

        return "Uncompute: No instance detected.\n"
    
    # Search for inverse subcircuits.
    def detect_inverse_subcircuit(self) -> bool:
        """Decide if there is a subcircuit which is the inverse circuit of another subcircuit in the quantum circuit.
        
        Returns:
            bool: True if such a subcircuit exists, False otherwise.
        """
        self.circuit.remove_final_measurements()
        depth: int = self.circuit.depth()
        step: int = 0
        max_step: int = depth // 2

        while step < max_step:
            window_start: int = 0
            window_end: int  = window_start + step
            compare_start: int = window_end + 1
            compare_end: int = compare_start + step

            while compare_end < depth:
                while compare_end < depth:
                    window_circ: QuantumCircuit = self.get_subcircuit(window_start, window_end)
                    compare_circ: QuantumCircuit = self.get_subcircuit(compare_start, compare_end)

                    # Probably more non-invertible operations have to be added here.
                    if Measure().name not in [gate[0].name for gate in compare_circ.data] \
                        and window_circ == compare_circ.inverse():

                        return True

                    compare_start += 1
                    compare_end += 1

                window_start += 1
                window_end += 1
                compare_start = window_end + 1
                compare_end = compare_start + step

            step += 1
        
        return False

    # Search for typical circuit structure.
    def detect_circuit_struc(self) -> bool:
        """Detect the typical circuit structure of Uncompute.
        
        Returns:
            bool: True if the circuit structure was detected, False otherwise.
        """
        dag: DAGCircuit = circuit_to_dag(self.circuit)

        # Stores all bit pairs where a cx gate has been applied to.
        # key: control bit
        # value: operating bit
        cx_nodes: dict[int, int] = {}

        added: bool = False
        
        for layer in dag.layers():
            for node in layer['graph'].front_layer():
                if node.name == CXGate().name:
                    c_bit: Qubit = node.qargs[0]
                    o_bit: Qubit = node.qargs[1]
                    c_bit_index: int = self.circuit.find_bit(c_bit).index
                    o_bit_index: int = self.circuit.find_bit(o_bit).index

                    # If cx operations overlap then it is unlikely this pattern.
                    if o_bit_index in cx_nodes.keys() or o_bit_index in cx_nodes.values() \
                        or c_bit_index in cx_nodes.values():
                        
                        cx_nodes.clear()

                    cx_nodes[c_bit_index] = o_bit_index
                    added = True

                if node.name == SwapGate().name:
                    first_bit: Qubit = node.qargs[0]
                    second_bit: Qubit = node.qargs[1]
                    first_bit_index: int = self.circuit.find_bit(first_bit).index
                    second_bit_index: int = self.circuit.find_bit(second_bit).index

                    for key in cx_nodes.copy().keys():
                        if (key == first_bit_index and cx_nodes[key] == second_bit_index) or \
                            key == second_bit_index and cx_nodes[key] == first_bit_index:

                            del cx_nodes[key]

                if added and not cx_nodes:
                    return True

        return False
    
    # Returns subcircuit from layer start to layer end (inclusive).
    def get_subcircuit(self, start: int, end: int) -> QuantumCircuit:
        """Computed the subcircuit of a given quantum circuit.

        The layers ``start`` and ``end`` are inclusive which means that they are in the subcircuit.
        
        Args:
            start (int): Number of the start layer of the subcircuit.
            end (int): Number of the end layer of the subcircuit.

        Returns:
            QuantumCircuit: The subcircuit from ``start`` to ``end``.
        """
        dag: DAGCircuit = circuit_to_dag(self.circuit)
        layers: list = list(dag.multigraph_layers())

        for layer in layers[:start+1]:
            for node in layer:
                if isinstance(node, DAGOpNode):
                    dag.remove_op_node(node)

        for layer in layers[end+2:-1]:
            for node in layer:
                if isinstance(node, DAGOpNode):
                    dag.remove_op_node(node)
                        
        return dag_to_circuit(dag)